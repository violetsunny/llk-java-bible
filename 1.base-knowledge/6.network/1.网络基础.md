# 名言
计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。

## 七层模型
物理层
首先解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到比特流。
物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。
主要作用是传输比特流（0101二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。
这层数据叫做比特。网卡工作在这层。
物理层是OSI七层模型的物理基础，没有它就谈不上数据传输了
物理层就是由实物所承载的，所以作比喻的话，公路、汽车和飞机等承载货物（数据）的交通工具，就是物理层的象征

数据链路层
在传输比特流的过程中，会产生错传、数据传输不完整的可能。
数据链路层定义了如何格式化数据进行传输，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。
本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。
该层负责物理层面上互连的节点之间的通信传输。例如与1个以太网相连的两个节点间的通讯。
常见的协议有 HDLC、PPP、SLIP等
数据链路层会将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）

网络层
随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。
网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。
网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A到另一个网络中节点B的最佳路径。
由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。
此层的数据称之为数据包。本层需要关注的协议TCP/IP协议中的IP协议。
网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。主要由 IP、ICMP 两个协议组成
网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是IP地址。IP地址通过不断转发到更近的IP地址，最终可以到达目标地址。

传输层
随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（Segement）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。
传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了传输质量的问题。
传输层需要关注的协议有TCP/IP协议中的TCP协议和UDP协议。

会话层
自动收发包，自动寻址。
会话层作用是负责建立和断开通信连接，何时建立，断开连接以及保持多久的连接。常见的协议有 ADSP、RPC 等

表示层
Linux给WIndows发包，不同系统语法不一致，如exe不能在Linux下执行，shell不能在Windows不能直接运行。于是需要表示层。
解决不同系统之间通信语法问题，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。
它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有ASCII、SSL/TLS 等。

应用层
规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。
应用层旨在更方便应用从网络中接收的数据，重点关注TCP/IP协议中的HTTP协议。

七层应用层数据是消息（Messages）或报文（Protocol Data Units, PDUs）；
六层表示层数据是数据（Data）；
五层会话层数据是会话（Sessions）；
四层传输层数据被称作段（Segments）；
三层网络层数据被称做包（Packages）；
二层数据链路层时数据被称为帧（Frames）；
一层物理层时数据被称为比特流（Bits）。

同一局域网内的网络连接可以使用交换机，不同区域的局域网互联使用路由器。路由器连接不同网段，负责不同网段之间的数据转发，交换机连接的是同一网段的计算机。

## 长连接和短连接
1.长连接需要通道一直开启，会一直发检测包保持，需要自己做在线维持（不发生RST包和四次挥手）
2.建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）

## 单全工，半双工，双全工通信模式
单全工通信模式：
单工通信是一种点对点的通信方式，其中数据只能在一个方向上流动。发送方只能发送数据，接收方只能接收数据，不能反向发送。数据传输是单向的，例如：电视广播

半双工通信模式：
在这种模式下，通信双方不能同时进行发送和接收。要么一方发送数据，另一方接收；要么反之。双方可以交替发送和接收数据，但不能在同一时刻既发送又接收。数据传输是双向的，但不是同时的。
例如，MCU 可以先向无线模块发送数据，发送完成后等待一段时间，然后切换为接收模式，等待无线模块的响应。而在这个过程中，无线模块在接收数据时不能发送，反之亦然。

双全工通信模式：
全双工通信允许数据同时在两个方向上流动。这意味着通信双方可以同时发送和接收数据，无需等待对方完成传输。数据传输是双向的，并且是同时的。例如：电话，视频通话

## Socket
即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）。

Socket不是一种协议，而是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输）

对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信。

Socket的生命周期：加载--实例化--初始化--请求数据的处理--销毁

1.加载：如果配置了自动加载项，则在启动服务器时自动加载（web.xml设置<load-on-start>）,在服务启动后，客户端首次向Servlet发出请求时，重新加载Servlet时
2.实例化：加载Serverlet后，服务器创建一个Servlet实例
3.初始化：调用Servlet的init方法，初始化参数被传递给Servlet配置对象ServletConfig
4.请求处理：对于到达服务器的客户机请求，服务器针对此次请求的请求对象和响应对象，服务器调用Serlvet的service方法，该方法用于传递请求和响应对象。service方法可以调用其他方法来处理请求，如doGet,doPost
5.销毁：当服务器不在需要Servlet，或重新装入新的Servlet的时候调用destory方法销毁。

## websocket
双全工(如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。)
先建立连接http，然后进行长链接通讯websocket，通过订阅模式获取数据，然后断开连接http。WebSocket 就是基于 TCP 长连接进行通信的。所谓双向通信，其重要的特征是服务端可以将数据主动推送到客户端。
connect-->subscribe

1.HTTP 请求先建立 TCP 握手：浏览器和服务器建立 TCP 连接，并进行三次握手，这是整个通信的基础。
2.WebSocket 开始握手：TCP 连接成功后，浏览器通过 HTTP 协议向服务器传送 WebSocket 支持的版本号等信息。
3.服务端响应 WebSocket 握手：服务器收到浏览器的握手请求后，同样采用 HTTP 协议回馈数据。
4.WebSocket 握手之后：当收到了连接成功的消息后，双方通过 TCP 通道进行传输通信。此时，复用了最早创建的 TCP 连接。

Websocket浏览器连接最多255.tomcat默认200，修改maxThreads。

## SMTP，POP3/IMAP
SMTP基于 TCP 协议，用来发送电子邮件。
POP3 和 IMAP 两者都是负责邮件接收的协议。

## FTP
FTP 协议主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。

FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：

控制连接：用于传送控制信息（命令和响应）
数据连接：用于数据传送；
这种将命令和数据分开传送的思想大大提高了 FTP 的效率。

## Telnet、SSH
Telnet 协议 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。

SSH（ Secure Shell） 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。

Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。

## ping
Ping是我们测试网络连接的常用指令。它利用ICMP报文检测网络连接。

假设A ping B:
1.ping通知系统建立一个固定格式的ICMP请求数据包。
2.ICMP协议打包这个数据包和B的IP地址转交给IP协议层
3.IP层协议将机器B的IP地址为目的地址，本机的IP地址为源地址，加上一些头部必要的控制信息，构建一个IP数据包
4.获取B的MAC地址，做这个操作首先机器A会判断B是否在同一网段内，若IP层协议通过B的IP地址和自己的子网掩码，发现它跟自己属于同一网络，就直接在本网络查找这台机器的MAC，否则则通过路由器进行类似查找。
接下来是ARP协议根据IP地址查找MAC地址的过程:
若两台机器之前有过通信，在机器A的ARP缓存表里应该存有B的IP与其MAC地址的映射关系。
若没有，则通过发送ARP请求广播，得到回应的B机器MAC地址，并交给数据链路层
5.数据链路层构建一个数据帧，目的地址是IP层传过来的MAC地址，源地址是本机的MAC地址，再附加一些必要的控制信息，依据以太网的介质访问规则将他们传送出去
6.机器B收到这个数据帧后，先检查目的地址，和本机MAC地址对比：
符合，接受，接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的的IP地址协议层协议，IP协议层检查之后，将有用的信息提取给ICMP协议，后者处理，马上构建一个ICMP应答包，发送给A，其过程和主机A发送ICMP请求包到B的过程类似，但不用ARP广播收取A的信息，因为请求包中已经有足够的信息用于B回应A。
若不符合，丢弃。

可以知道PING的过程即一段发送报文和接受确认报文的过程，在来回直接可以计算时延。

ARP即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。

ARP协议的工作过程：
首先，每个主机都会有自己的ARP缓存区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系
当源主机要发送数据时，首先检测ARP列表中是否对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包
当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果存在，则覆盖然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
源主机收到ARP响应包后，将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据，如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

## DNS
DNS通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。

通俗的讲，我们更习惯于记住一个网站的名字，www.baidu.com，而不是记住它的ip地址，比如：167.23.10.2
工作原理:
将主机域名转换为ip地址，属于应用层协议，使用UDP传输。
第一步，客户端向本地DNS服务器发送解析请求
第二步，本地DNS如有相应记录会直接返回结果给客户端，如没有就向DNS根服务器发送请求
第三步，DSN根服务器接收到请求，返回给本地服务器一个所查询域的主域名服务器的地址
第四步，本地dns服务器再向返回的主域名服务器地址发送查询请求
第五步，主域名服务器如有记录就返回结果，没有的话返回相关的下级域名服务器地址
第六步，本地DNS服务器继续向接收到的地址进行查询请求
第七步，下级域名服务器有相应记录，返回结果
第八步，本地dns服务器将收到的返回地址发给客户端，同时写入自己的缓存，以便下次查询

DNS域名查询实际上就是个不断递归查询的过程，直到查找到相应结果，需要注意的时，当找不到相应记录，会返回空结果，而不是超时信息。

DNS记录：
A记录：
www.example.com.     IN     A     139.18.28.5;
上面的就是一条 DNS 记录，纯文本即可。
www.example.com 是要解析的域名。A 是记录的类型，A 记录代表着这是一条用于解析 IPv4 地址的记录。
从这条记录可知，www.example.com的 IP 地址是 139.18.28.5。

CNAME，CNAME用于定义域名的别名，如下面这条 DNS 记录：
定义www.example.com的别名：
a.example.com.          IN     CNAME   b.example.com.
这条 DNS 记录定义了 a.example.com 是 b.example.com 的别名。
用户在浏览器中输入 a.example.com 时候，通过 DNS 查询会知道 a.example.com 是 b.example.com 的别名，因此需要实际 IP 的时候，会去拿 b.example.com 的 A 记录。
当你想把一个网站迁移到新域名，旧域名仍然保留的时候；还有当你想将自己的静态资源放到 CDN 上的时候，CNAME 就非常有用。

AAAA 记录
A 记录是域名和 IPv4 地址的映射关系。和 A 记录类似，AAAA 记录则是域名和 IPv6 地址的映射关系。

MX记录
MX 记录是邮件记录，用来描述邮件服务器的域名。
在工作中，我们经常会发邮件到某个同事的邮箱。
比如说，发送一封邮件到 xiaoming@xiaoflyfish.com，那么如何知道哪个 IP 地址是邮件服务器呢？
这个时候就可以用到下面这条 MX 记录：
IN MX mail.xiaoflyfish.com
mail.xiaoflyfish.com 的 IP 地址可以通过查询 mail.xiaoflyfishcom 的 A 记录和 AAAA 记录获得。

NS 记录
NS记录是描述 DNS 服务器网址。从 DNS 的存储结构上说，Name Server 中含有权威 DNS 服务的目录。
也就是说，NS 记录指定哪台 Server 是回答 DNS 查询的权威域名服务器。
当一个 DNS 查询看到 NS 记录的时候，会再去 NS 记录配置的 DNS 服务器查询，得到最终的记录。如下面这个例子：
a.com.     IN      NS      ns1.a.com.
a.com.     IN      NS      ns2.a.com.
当解析 a.com 地址时，我们看到 a.com 有两个 NS 记录，所以确定最终 a.com 的记录在 ns1.a.com 和 ns2.a.com 上。
从设计上看，ns1 和 ns2 是网站 a.com 提供的智能 DNS 服务器，可以提供负载均衡、分布式 Sharding 等服务。
比如当一个北京的用户想要访问 a.com 的时候，ns1 看到这是一个北京的 IP 就返回一个离北京最近的机房 IP。
上面代码中 a.com 配置了两个 NS 记录。
通常 NS 不会只有一个，这是为了保证高可用，一个挂了另一个还能继续服务。
通常数字小的 NS 记录优先级更高，也就是 ns1 会优先于 ns2 响应。
配置了上面的 NS 记录后，如果还配置了 a.com 的 A 记录，那么这个 A 记录会被 NS 记录覆盖。

## 数字签名
网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改
数字签名校验数据的完整性

数字签名有两种功效：
能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。
数字签名能确定消息的完整性，证明数据是否未被篡改过。

将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者
接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。
如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。

## 加密算法
加密算法分对称加密 和 非对称加密，其中对称加密算法的加密与解密密钥相同，非对称加密算法的加密密钥与解密密钥不同，此外，还有一类不需要密钥的散列算法。
常见的 对称加密 算法主要有 DES、3DES、AES 等，常见的 非对称算法 主要有 RSA、DSA 等，散列算法 主要有 SHA-1、MD5 等。

对称加密
在 对称加密算法 中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行 加密 和 解密。
数据加密过程：在对称加密算法中，数据发送方 将 明文 (原始数据) 和 加密密钥 一起经过特殊 加密处理，生成复杂的 加密密文 进行发送。
数据解密过程：数据接收方 收到密文后，若想读取原数据，则需要使用 加密使用的密钥 及相同算法的 逆算法 对加密的密文进行解密，才能使其恢复成 可读明文。

非对称加密
非对称加密算法，它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。
因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。
如果使用 公钥 对数据 进行加密，只有用对应的 私钥 才能 进行解密。
如果使用 私钥 对数据 进行加密，只有用对应的 公钥 才能 进行解密。
例子：甲方生成 一对密钥 并将其中的一把作为 公钥 向其它人公开，得到该公钥的 乙方 使用该密钥对机密信息 进行加密 后再发送给甲方，甲方再使用自己保存的另一把 专用密钥 (私钥)，对 加密 后的信息 进行解密。

**生成私钥**：在生成密钥对的过程中，首先生成私钥。私钥是一个随机数，需要足够大以确保安全性。

**生成公钥**：使用私钥和算法的特定数学公式来生成公钥。公钥可以由任何人使用，但只有对应的私钥才能解密。

下面是一个使用OpenSSL生成RSA密钥对的例子：
openssl genrsa -out private_key.pem 2048  # 生成2048位的私钥
openssl rsa -in private_key.pem -pubout -out public_key.pem  # 从私钥生成公钥

## 网络攻击
XSS：
跨站脚本是一种网站应用程序的安全漏洞攻击，是代码注入的一种。
它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响，这类攻击通常包含了HTML以及用户端脚本语言。
比如通过客户端脚本语言（最常见如：JavaScript）
持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。
比如再内容字段存入：<script>alert(‘foolish!’)；</script> <!--或者html其他标签（破坏样式。。。）、一段攻击型代码-->

CSRF：
跨站请求伪造，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。
比如冒充用户发起请求（在用户不知情的情况下），完成一些违背用户意愿的请求（如恶意发帖，删帖，改密码，发邮件等）。

DOS攻击
DOS：中文名称是拒绝服务，该攻击的效果是使得计算机或网络无法提供正常的服务
DOS攻击的原理：
首先攻击者向被攻击的服务器发送大量的虚假IP请求，被攻击者在收到请求后返回确认信息，等待攻击者进行确认，该过程需要TCP的三次握手，由于攻击者发送的请求信息是虚假的，所以服务器接收不到返回的确认信息，在一段时间内服务器会处与等待状态，而分配给这次请求的资源却被有被释放
当被攻击者等待一定的时间后，会因连接超时而断开，这时攻击者在次发送新的虚假信息请求，这样最终服务器资源被耗尽，直到瘫痪。
DDOS：中文名称是分布式拒绝服务攻击，指的是攻击者控制多台主机同时向同一主机或网络发起DOS攻击，DRDoS分布反射式拒绝服务攻击这是DDoS攻击的变形。

DDOS究竟如何攻击：
目前最流行也是最好用的攻击方法就是使用SYN-Flood进行攻击，SYN-Flood也就是SYN洪水攻击
SYN-Flood不会完成TCP三次握手的第三步，也就是不发送确认连接的信息给服务器，这样，服务器无法完成第三次握手，但服务器不会立即放弃，服务器会不停的重试并等待一定的时间后放弃这个未完成的连接，这段时间叫做SYN timeout，这段时间大约30秒-2分钟左右。
若是一个用户在连接时出现问题导致服务器的一个线程等待1分钟并不是什么大不了的问题，但是若有人用特殊的软件大量模拟这种情况，那后果就可想而知了。一个服务器若是处理这些大量的半连接信息而消耗大量的系统资源和网络带宽，这样服务器就不会再有空余去处理普通用户的正常请求(因为客户的正常请求比率很小)，这样这个服务器就无法工作了，这种攻击就叫做SYN-Flood攻击
到目前为止，进行DDoS攻击的防御还是比较困难的。
首先，这种攻击的特点是它利用了TCP/IP协议的漏洞，除非你不用TCP/IP，才有可能完全抵御住DDoS攻击，不过这不等于我们就没有办法阻挡DDoS攻击，我们可以尽力来减少DDoS的攻击。

下面就是一些防御方法:
1.关闭不必要的服务
2.限制同时打开的SYN半连接数目
3.缩短SYN半连接的time out 时间
4.正确设置防火墙
5.禁止对主机的非开放服务的访问
6.限制特定IP地址的访问
7.启用防火墙的防DDoS的属性

## 16进制
16进制就是逢16进1，但我们只有0~9这十个数字，所以我们用A，B，C，D，E，F这六个字母来分别表示10，11，12，13，14，15。字母不区分大小写。
C，C++规定，16进制数必须以 0x开头。

假设有一个十六进数 2AF5, 那么如何换算成10进制呢？
用竖式计算：
2AF5换算成10进制:
第0位： 5 * 16^0 = 5
第1位： F * 16^1 = 240
第2位： A * 16^2 = 2560
第3位： 2 * 16^3 = 8192 +
-------------------------------------
10997
直接计算就是：
5 * 16^0 + F * 16^1 + A * 16^2+2 * 16^3 = 10997
(别忘了，在上面的计算中，A表示10，而F表示15)

## HEX算法
Byte 存储实际数值的情况：

假定有 1Byte，里面存放的数值是十进制 226
那么它存储的 8 位二进制值是 1110'0010
高4位是 1110
低4位是 0010
Hex编码的时候，先取高 4 位 1110 转成十六进制的 e ，然后去寻找字符 "e" 对应的 ascii 码，即为 0110'0101
再取低 4 位 0010 转成十六进制的 2 ，然后去寻找字符 "2" 对应的 ascii 码，即为 0011'0010
最终转换后的数据是 0110'0101 0011'0010
按照字符串显示就是 e2

Byte 存储字符的情况：

假定有 1Byte，里面存放的是字符 "g"
那么它存储的 8 位二进制值是 0110'0111
高4位是 0110
低4位是 0111
Hex编码的时候，先取高 4 位 0110 转成十六进制的 6 ，然后去寻找字符 "6" 对应的 ascii 码，即为 0011'0110
再取低 4 位 0111 转成十六进制的 7 ，然后去寻找字符 "7" 对应的 ascii 码，即为 0011'0111
最终转换后的数据是 0011'0110 0011'0111
按照字符串显示就是 67