## ELK
filebeat 收集业务日志，每个镜像和虚拟机只需要一个即可，配置文件打印路径。input配置收集路径格式，output配置发送host（也可以发送kafka，logsatsh从kafka消费）
logstash 接收filebeat的日志，设置索引格式(可以按照天维度)放入ES
ES 存储日志数据
kibana 展示ES数据

## Elasticsearch
Elasticsearch既可以处理结构化数据，也可以处理半结构化和非结构化数据。例如：结构化的是存储固定对象的json格式，半结构化的存储多种对象的xml和json格式，非结构化的就是可以存储文本、图像、音频、视频等形式的数据。从这方面来说，我们大部分使用ES，其实存储的还是半结构化数据。

Elasticsearch 有以下几个重要概念：
一、索引（Index）
索引是 Elasticsearch 中用于存储和管理数据的逻辑空间，类似于关系型数据库中的数据库。
它由一个或多个分片组成，每个分片都是一个独立的 “小型索引”，可以存储在不同的节点上。

二、类型（Type）
Elasticsearch 6.0 开始，逐渐不建议使用多类型，7.0 版本中更是明确表示将在未来版本中移除多类型的支持。现在，一个索引通常只对应一种类型的文档
三、文档（Document）
文档是 Elasticsearch 中存储数据的基本单位，类似于关系型数据库中的一行记录。
它由一组字段组成，每个字段都有一个名称和一个值。
无固定结构：文档可以具有不同的字段，不像关系型数据库中的表需要预先定义固定的结构。
JSON 格式：文档以 JSON（JavaScript Object Notation）格式存储，具有良好的可读性和灵活性。
可被索引和搜索：文档可以被索引，以便进行快速的搜索和查询。

三、字段（file）
字段都有对应名称和值的数据类型。类似于表的列。


高可用性（High Availability）：
通过副本和主节点选举机制，确保集群在节点故障时继续运行。
冷热架构（Hot-Warm Architecture）：
将数据分为热数据和冷数据，热数据存储在高性能节点上，冷数据迁移到成本较低的存储上。
版本控制（Versioning）：
Elasticsearch为每个文档维护版本信息，处理并发更新和删除操作。

由于ES通常数据量很大，一般也需要一个定期删除机制。如果是按照时间建索引，可以设置多久之前的索引进行删除。以保证数据量在可控范围。

## ES集群
节点（Node）
节点是 Elasticsearch 集群中的一个服务器实例，它可以存储数据、处理查询请求，并参与集群的管理。
主节点（Master Node）：负责管理集群的状态，如分配分片、处理节点加入和离开等。主节点不存储数据，主要承担管理职责。
数据节点（Data Node）：存储数据分片，并处理与数据相关的查询请求。
客户端节点（Client Node）：不存储数据，也不参与集群的管理，主要用于向集群发送查询请求，并将结果返回给客户端。

集群（Cluster）
集群是由一个或多个节点组成的集合，共同协作来存储和处理数据。
高可用性：通过将数据分布在多个节点上，即使部分节点出现故障，整个集群仍然可以继续提供服务。
可扩展性：可以通过添加节点来扩展集群的存储容量和处理能力。
自动故障转移：当主节点出现故障时，集群会自动选举新的主节点，确保集群的正常运行。

分片（Shard）
分片是将一个索引的数据拆分成多个较小的部分，每个分片可以存储在不同的节点上。
分片的主要作用是实现数据的分布式存储和并行处理，提高系统的可扩展性和性能。
主分片与副本分片：
每个索引都可以被分成一个或多个主分片（Primary Shard），主分片负责存储实际的数据。
为了提高数据的可用性和查询性能，可以为每个主分片创建一个或多个副本分片（Replica Shard）。副本分片是主分片的备份，当主分片出现故障时，副本分片可以接替主分片的工作。

在 Elasticsearch（ES）中，分片（shard）是一种将数据分布在多个节点上的机制，主要有以下几个方面的含义和作用：
一、数据存储和分布
（1）物理分割：
分片是将一个索引的数据拆分成多个较小的部分。每个分片本身就是一个功能齐全且独立的 “小型索引”，可以存储在不同的节点上。
例如，假设有一个包含大量文档的索引，如果不进行分片，这个索引可能会变得非常庞大，难以管理和查询。通过将其分成多个分片，可以将数据分散存储在不同的物理位置，提高存储的可扩展性。
（2）分布式存储：
ES 是一个分布式搜索引擎，分片允许数据在多个节点上进行分布式存储。这意味着可以通过增加节点来扩展存储容量，而无需对单个节点进行大规模的升级。
Elasticsearch会尝试均匀地将分片分配到集群的所有节点上，这个过程称为分片分配。
当数据被写入索引时，ES 会自动将数据分配到不同的分片上，确保数据在整个集群中均匀分布。这样可以避免单个节点存储过多数据而导致性能瓶颈。
通常建议每个分片的大小在10GB到50GB之间，这有助于保持搜索性能和管理的简便性。
二、查询处理和性能
（1）并行处理：
在查询数据时，ES 可以并行地在多个分片上执行查询操作。每个分片独立处理一部分查询任务，然后将结果合并返回给用户。
这种并行处理方式可以大大提高查询性能，尤其是对于大规模数据的查询。例如，当执行一个复杂的全文搜索查询时，ES 可以同时在多个分片上进行搜索，然后将各个分片的结果汇总，从而快速返回最终的查询结果。
（2）负载均衡：
分片有助于实现负载均衡。由于数据分布在多个分片上，查询负载也会分散到不同的节点上。
这样可以避免单个节点承受过多的查询压力，提高整个集群的稳定性和性能。如果某个节点出现故障，其他节点上的分片仍然可以继续处理查询请求，确保系统的可用性。
三、可扩展性和灵活性
（1）动态调整：
ES 允许在运行时动态地调整分片的数量和分布。这意味着可以根据实际业务需求和数据增长情况，灵活地增加或减少分片的数量。
例如，如果数据量不断增长，可以通过增加分片的数量来扩展存储容量和提高查询性能。相反，如果数据量减少或资源紧张，可以合并一些分片以减少资源占用。
（2）集群扩展：
当向 ES 集群添加新的节点时，分片可以自动在新节点上进行重新分配，以实现更好的负载均衡和性能优化。
这种动态的分片管理机制使得 ES 能够轻松应对不断变化的业务需求和数据规模，提供高度的可扩展性和灵活性。
（3）高可用：
主分片（Primary Shard）：每个索引在创建时会定义一定数量的主分片，它们存储实际的数据。
副本分片（Replica Shard）：为了提高数据的可用性和搜索操作的并发性，每个主分片可以有零个或多个副本分片。
分片恢复：Elasticsearch会自动恢复失败的分片，将副本分片提升为主分片，或重新分配丢失的主分片副本。

总之，分片是 Elasticsearch 中一个非常重要的概念，它通过将数据分布在多个节点上，实现了分布式存储、并行处理、负载均衡和可扩展性，为大规模数据的存储和查询提供了高效的解决方案。

Elasticsearch是如何避免脑裂现象的：
当集群中master候选的个数不小于3个（node.master:true）。可以通过discovery.zen.minimum_master_nodes

这个参数的设置来避免脑裂，设置为(N/2)+1。

这里node.master : true 是说明你是有资格成为master，并不是指你就是master。是皇子，不是皇帝。假如有10个皇子，这里应该设置为（10/2）+1=6，这6个皇子合谋做决策，选出新的皇帝。另外的4个皇子，即使他们全聚一起也才四个人，不足合谋的最低人数限制，他们不能选出新皇帝。

假如discovery.zen.minimum_master_nodes 设置的个数为5，有恰好有10个master备选节点，会出现什么情况呢？5个皇子组成一波，选一个皇帝出来，另外5个皇子也够了人数限制，他们也能选出一个皇帝来。此时一个天下两个皇帝，在es中就是脑裂。

假如集群master候选节点为2的时候，这种情况是不合理的，最好把另外一个node.master改成false。如果我们不改节点设置，还是套上面的(N/2)+1公式，此时discovery.zen.minimum_master_nodes应该设置为2。这就出现一个问题，两个master备选节点，只要有一个挂，就选不出master了。
我还是用皇子的例子来说明。假如先皇在位的时候规定，必须他的两个皇子都在的时候，才能从中2选1 继承皇位。万一有个皇子出意外挂掉了，就剩下一个皇子，天下不就没有新皇帝了么。

## ES建模
1.基于业务角度建模
多索引管理一般优先推荐使用模板（template）和 别名（alias）结合的方式。
模板的特点：相同前缀名称的索引可以归结为一大类，一次创建，N 多索引共享，非常方便。
当有多个索引具有相同的结构和配置需求时，模板非常实用。以相同前缀名称的索引为例，比如业务中涉及不同时间段的销售数据索引，可以命名为 “sales_index_2023”“sales_index_2024” 等，这些索引可以通过一个模板进行统一管理。模板一次创建后，多个索引共享相同的设置，大大减少了重复配置的工作量。例如，可以在模板中定义索引的分词器、字段映射等，新的索引创建时会自动应用这些设置。

别名的特点：多个索引可以映射到一个别名，方便多索引以相同的名称统一对外提供服务。
别名提供了一种灵活的方式来统一管理多个索引。多个索引可以映射到一个别名，这样对外提供服务时，无需关心具体的索引名称，只需要使用别名即可。比如，有多个不同日期的日志索引 “log_index_202301”“log_index_202302” 等，可以将它们都映射到一个别名 “current_logs”。当需要查询所有日志时，直接使用别名进行查询，方便快捷。同时，如果需要更换实际使用的索引，只需要修改别名指向的索引即可，不会影响上层应用的查询逻辑。

2.基于数据量角度建模
对于时序性数据（日志数据、舆情数据）等，我强烈建议你基于时间切分索引，例如，按天、周或月创建索引，可以避免单个索引过大，也可以减少范围查询，提高查询性能。特定业务数据配合冷热集群架构，确保高配机器对应热数据，提升检索效率和用户体验。

3.基于 Setting 层面建模
Setting 层面又分为静态 Setting 和动态 Setting 两种。
一种是静态 Settings，一旦设置后，后续不可修改。如 number_of_shards（分片数量）。
另一种是动态 Setting，索引创建后，后面随时可以更新。如 number_of_replicas（副本数量）可以根据系统负载和数据重要性进行调整。在系统负载较高时，可以增加副本数量以提高查询的并发能力；在数据重要性较低时，可以适当减少副本数量以节省存储资源。max_result_window（最大结果窗口）和refresh_interval（刷新间隔）也可以根据实际需求进行动态调整，以平衡查询性能和资源消耗。

4.基于 Mapping 层面建模
（1）字段命名要规范：
良好的字段命名规范有助于提高数据的可读性和可维护性。字段命名应该具有明确的含义，能够准确反映其所代表的数据内容。
（2）字段类型要合理
不同字符串类型的选择：
字符串类型分为text和keyword两种，需要根据实际业务需求进行选择。text类型用于处理全文搜索，适合存储文本内容较多的字段，如文章内容、评论等。它会对文本进行分词处理，以便进行全文搜索。keyword类型用于处理结构化数据，适合存储关键词和聚合操作，如标签、分类等。它不会进行分词处理，而是将整个字段作为一个关键词进行存储和查询。
选择贴近实际大小的数据类型：
在选择数据类型时，应尽量选择贴近实际大小的数据类型，以节省存储空间和提高查询性能。例如，如果一个字段存储的是整数，且数值范围较小，可以选择integer类型而不是long类型。如果一个字段存储的是日期，可以选择date类型而不是text类型，以便进行日期范围查询和排序。
复杂类型的选型：
nested和join复杂类型需要根据业务特点进行选型。nested类型适用于 1 对少量，子文档偶尔更新、查询频繁的场景。例如，一个订单包含多个商品信息，商品信息可以作为nested类型存储在订单索引中。join父子文档方案适用于子文档数据量明显多于父文档的数据量，存在 1 对多量的关系且子文档更新频繁的场景。例如，一个博客文章有多个评论，评论可以作为子文档通过join类型与文章关联起来。
（3）分词器要灵活
不同分词器的特点与适用场景：
Standard Tokenizer是默认分词器，根据空白字符和标点符号分词，适用于大多数英文文本的分词处理。对于中文文本，使用IK分词器效果更好。ik_max_word最细粒度划分，适合Term Query（词条查询），能够将文本分成最细粒度的词条，提高查询的准确性。ik_smart最粗粒度划分，适合Phrase Query（短语查询），能够将文本分成较大的短语，提高查询的效率。
（4）multi_fields 适机使用
multi_fields可以同时设置多个类型，为字段提供更多的查询和分析方式。例如，可以为一个字段同时设置text和keyword类型，以便进行全文搜索和关键词搜索。在使用multi_fields时，需要根据业务需求选择合适的类型组合，并考虑查询性能和存储空间的平衡。

首先，根据业务选择合适的数据类型。
注意字符串类型分为两种 text（处理全文搜索）和 keyword（处理结构化数据，关键词搜索和聚合）；尽量选择贴近实际大小的数据类型；nested 和 join 复杂类型需根据业务特点选型。
其次，判定是否需要检索，如果不需要，index 设置为 false 即可。
然后，判定是否需要排序和聚合操作，如果不需要可以设置 doc_values 为 false。
最后，考虑一下是否需要另行存储，会结合使用 store 和 _source 字段。

5.基于复杂索引关联建模
（1） 宽表方案
宽表方案是一种空间换时间的存储方式，允许部分字段冗余存储。在某些业务场景下，为了提高查询性能，可以将多个相关表的数据整合到一个宽表中。这样可以避免多表关联查询，减少查询的复杂性和时间开销。例如，在电商业务中，可以将用户信息、订单信息和商品信息整合到一个宽表中，以便快速查询用户的订单和购买历史。
（2） nested 方案
nested方案适用于 1 对少量，子文档偶尔更新、查询频繁的场景。例如，一个订单包含多个商品信息，商品信息可以作为nested类型存储在订单索引中。在查询订单时，可以同时查询商品信息，而无需进行多表关联查询。nested类型的查询性能相对较好，但会占用一定的存储空间。
（3） join 父子文档方案
join父子文档方案适用于子文档数据量明显多于父文档的数据量，存在 1 对多量的关系且子文档更新频繁的场景。例如，一个博客文章有多个评论，评论可以作为子文档通过join类型与文章关联起来。在使用join类型时，需要注意查询性能的影响。由于父子文档之间的关联需要进行额外的查询和合并操作，所以查询性能可能会比nested方案和宽表方案低。同时，父子文档的更新也需要谨慎处理，以确保数据的一致性。
（4） 业务层面实现关联
尤其应该避免多表关联。 Nested 嵌套可以使查询慢几倍，而 Join 父子关系可以使查询慢数百倍。

## 在并发情况下，Elasticsearch如果保证读写一致？
可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；
另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。
对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。

## es使用场景
个人认为ES是写和读都不是很有优势的存储库，最大的优势就是它的存储结构，可以通过source查询到内容能匹配的数据。这样就非常适合复杂场景的查询，比如多维度的订单，不规则日志，不同项目服务订单汇合的客服系统等，简单来说就是适合多服务的结果汇集查询比较方便，不需要整理一个大宽表或者不规则数据做冗余等。 所以Elasticsearch 在全文搜索和数据分析方面表现出色。解决了灵活的数据存储和处理，高效的全文搜索，实时数据分析。

向 Elasticsearch 中存储数据，其实就是向 Elasticsearch 中的 index 下面的 type 中存储 JSON 类型的数据。

