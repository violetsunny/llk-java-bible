## redis支持的数据类型
String字符串、Hash（哈希/bean）、List（双向列表/LinkedList）、Set（集合不允许重复/可以做交集(SINTER)，并集(SUNION)，差集(Dict)）、ZSet(Sorted Set：有序集合/跳跃链表/(score-value))、BitMap（位）、Geo(地理位置)、HyperLogLog（基数）、Streams（流）

String 对应着 Redis 内部的 SDS （Simple Dynamic String），在 44 字节以内，使用 embstr 实现；超过了 44 字节，使用 raw 来存储。应用：分布式缓存，分布式全局ID，限流，分布式session
List 在数据少的时候对应着 ZipList，在数据多的时候对应着 LinkedList，并且 Redis 在 3.2 之后引入了 QuickList。应用：消息队列，发红包的场景
Hash 在数据少的时候对应着 ZipList，其他对应着 HashTable。条件：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）
所有值都小于hash-max-ziplist-value配置（默认64字节）。应用：购物车功能，对象类型数据
Set 对应着以IntSet或者HashTable来存储。对于Set来说，该HashTable的value值用于为NULL，通过key来存储元素。应用：标签管理功能，共同好友等
ZSet(Sorted set) 对应着 ZipList+Dict/SkipList。应用：排行榜系统
Geo 算经纬度
HyperLogLog 基数统计。应用：对数据进行统计
BitMap 对应String中的bit位。应用：记录只有0/1两种状态的数据,如男女，登录未登录等


## Redis这样设计有两个好处
1.可以偷偷的改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动对外数据结构和命令。
2.多种内部编码实现可以在不同场景下发挥各自的优势。例如ziplist比较节省内存，但是在列表元素比较多的情况下，性能会有所下降。这时候Redis会根据配置选项将列表类型的内部实现转换为linkedlist。

## String SDS结构
struct sdshdr{
int free; // buf[]数组未使用字节的数量
int len; // buf[]数组所保存的字符串的长度
char buf[]; // 保存字符串的数组
}
在SDS结构中len属性记录了字符串的长度，所以我们获取一个字符串长度直接取len的值，复杂度是O(1)。提高并发性。
当我们需要修改数据时，首先会检查当前SDS空间len是否满足，不满足则自动扩容空间至修改所需的大小，然后再执行修改，减少数据溢出。

String : sdshdr的结构,里面除了保存字符串buf，还保存了free（表示buf中剩余的空间）以及len（当前子字符串的长度）。  int,raw,embstr
1.获取字符串长度的复杂度为O(1) 2.不会造成缓冲区溢出 3.减少修改字符串带来的内存重分配次数 4.二进制安全  5.兼容部分C字符串函数


SDS通过两种内存重分配策略，很好的解决了字符串在增长和缩短时的内存分配问题：
1.预分配
如果对 SDS 字符串修改后，len 值小于 1M，那么此时额外分配未使用空间 free 的大小与len相等。
如果对 SDS 字符串修改后，len 值大于等于 1M，那么此时额外分配未使用空间 free 的大小为1M。
2.惰性释放
当缩短SDS字符串后，并不会立即执行内存重分配来回收多余的空间，而是用free属性将这些空间记录下来，如果后续有增长操作，则可直接使用。

不能存'\0'的数据，如视频等

## Redis常用命令？
Setex 设置key和过期时间,
Mget/Mset 同时获取多个,
Getset先取再赋值,
Incr对value自增,
ttl剩余超时时间秒,
pttl剩余超时时间毫秒,
exprire设置超时时间,
lpop 删除并返回第一个值 rpush 列表最后添加一个元素,
keys 查看key

## redis事务
multi命令开启，exec执行，discard放弃执行。Watch可以用来监视key是不是有被人操作。

这个过程是这样的：
1.开始事务（MULTI）。
2.命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。
3.执行事务(EXEC)。
你也可以通过 DISCARD 命令取消一个事务，它会清空事务队列中保存的所有命令。

Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）。但是因为Redis是单线程执行的，所以满足隔离性和一致性。

可以将 Redis 中的事务就理解为 ：Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。

## 使用过Redis分布式锁么，它是怎么实现的？
先拿setnx(SET if Not eXists)来争抢锁，setnx是当key不存在进行set,成功返回1失败返回0。抢到之后，再用expire/setex给锁加一个过期时间防止锁忘记了释放，防止del没有执行，没有释放锁造成死锁。
SET key value [EX seconds] [PX milliseconds] [NX|XX]
EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行SETEX key seconds value
PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。
NX ： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。
XX ： 只在键已经存在时， 才对键进行设置操作。
更好的是用setnx px 设置超时时间，key最好加标记。 set key value ex 5 nx

可以用lua脚本保证原子性 eval命令执行lua脚本，Lua 通过 call() 或 pcall() 函数执行 Redis 命令，Redis使用的是单个lua脚本解析器，会保证脚本的原子性。注意lua脚本是不满足原子性的，因为前面的执行报错以后前面已经执行的命令是无法撤销的。
可自旋等待或者直接返回  监听上锁的key
set的key要业务唯一，值可以是请求id等业务标识，这样可以保证是本人解锁

解锁，可以删除key del。设置超时时间，需要续租。

redis需要对key设置超时是为了防止死锁，value要设置自己的标记是为了key被其他人解锁导致自己无法判断出错（如：自己的锁超时释放了，然后程序执行结束再去解锁可能释放的是别人的锁）。集群下，不保证锁的唯一。

## 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？
set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！Lua脚本做

可以 set key value ex 5 nx

## 使用过Redis做异步队列么，你是怎么用的？有什么缺点？
一般使用list结构作为队列，rpush生产消息，lpop（移除并返回数据）消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
缺点：
在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。

## 能不能生产一次消费多次呢？
使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

## Redis的过期和删除机制
Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。

定期删除+惰性删除

1.定期删除是Redis每隔一段时间（默认100ms）会随机抽取一些设置了过期时间的key,检测这些key是否过期，如果过期了则删除
2.惰性删除不是主动删除，采用的是Redis主动删除，在客户端获取key的时候检测key是否过期，如果没有过期则返回给客户端，如果过期了则会删除。

## Redis 有哪几种数据淘汰策略
1.noeviction:当内存达到阈值，所有申请内存命令返回错误。  默认
2.allkeys-lru/lfu: 尝试回收最少使用的键(LRU)，使得新添加的数据有空间存放。
3.volatile-lru/lfu: 尝试回收最少使用的键(LRU)，但仅限于在设置了过期时间集合的键,使得新添加的数据有空间存放。
4.allkeys-random: 回收随机的键使得新添加的数据有空间存放。
5.volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在设置了过期时间集合的键。
6.volatile-ttl: 回收在过期集合的键，并且优先回收存活时间(TTL)较短的键,使得新添加的数据有空间 存放。
7.volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰
8.allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

## 什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？
缓存穿透
一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。本身就不存在，还要大量访问，这就叫做缓存穿透。
如何避免？
1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。
2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。（Redis布隆过滤器：hash冲突和更新失败问题导致存在的数据被拦截）
bitMap是一种二进制set结构，对key进行三次hash打到不同的位置进行标记1,这样其他相同的数查询时候查看是否有标记0即可，但是会出现key3不存在但是打中key1和key2标记的情况。不存在就是不存在，存在不一定存在。 Bitmap后先调用recycle()，再赋为null。

缓存击穿
热点key的过期，大量请求到DB。（经常删除热点缓存key容易引起这个问题，不要用闪电缓存）。本身存在，但是缓存中不存在了，这是缓存击穿。
1.加锁
2.在value里设置超时时间，并提前异步更新。异步主动刷新要注意不能删除而是覆盖更新。
3.另设置一个标签缓存，当标签开始过期时，异步更新热点key
4.考虑本地缓存做缓冲：要考虑内存问题，毕竟可能缓存的是全部key
5.永不过期

缓存雪崩
当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。大量的key失效，导致系统崩溃。
如何避免？
1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期
3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。比如：固定时间+范围内随机时间 random.nextInt(1000)
4:   做缓存预热，定期的对数据更新。
5：和服务器一样。服务降级，给热点服务提供支撑，异地多活，多个集群。

异常降级
当下游出现异常的时候，缓存更新策略如下：
下游是非核心：超时异常写一个短暂的空缓存（例如：30s 过期，10s刷新），防止下游超时，影响上游服务的稳定性。
下游是核心：异常时不更新缓存，下次请求再更新，防止写入空缓存，阻断了核心流程。

redis缓存降级：
和服务降级差不多，都是看哪些业务可以暂时停止服务，提升服务可靠性。
主动抛弃或者对降级服务返回可以付特定值进行特殊处理，避免服务异常。

## 什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？
Redis 提供了两种持久化方式:
RDB（默认）：功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数，定时快照（存储在内存里面的数据在某个时间点上的副本）方式存储二进制文件
AOF ：每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作
aof写入保存：
WRITE：每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 server.aof_buf 中。
SAVE：根据 appendfsync 配置，将 server.aof_buf 中的缓存写入到 AOF 文件。
是一种高频追加写入文件的方式，记录的是操作命令。

在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：
appendfsync always    #每次有数据修改发生时都会写入AOF文件,会阻塞线程，这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步

AOF重写：当执行重写命令时，Redis会开启一个AOF重写缓冲区，该缓冲区会记录服务器执行的所有写命令。在完成创建新 AOF 文件之后，会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据状态与现有的数据状态一致。最后，Redis用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。

Redis采用的是写后日志，就是先执行命令再写日志，这样只会记录执行成功的命令日志，而且不会阻塞操作命令。但是写后日志有数据丢失的风险。

RDB在生成快照数据时，采用save和bgsave两个方式，save命令是在主线程中执行的，会阻塞线程，bgsave是另起线程操作，不会阻塞主线程。bgsave会导致数据被修改，采用副本的方式，bgsave会将副本数据写入RDB文件，而主线程仍然可以修改原数据。

比较：
1、aof文件比rdb更新频率高，优先使用aof还原数据。
2、aof比rdb更安全也更大
3、rdb性能比aof好
4、可以两个都配，会优先加载AOF

## Redis架构？
单机、主从、哨兵（Sentinel）、集群（cluster 保存每个节点数据和整个集群状态 循环网状结构）

redis分片：
每个分片都是主库，每个分片都有自己的“主 - 从”模式结构。对于 key，找到对应的机器分片号 hash(key)%3，hash 算法有很多，可以用 CRC16(key)，也可以直接取 key 中的字符，通过 ASCII 码转换成数字。

主从+哨兵：
主服务负责写，从服务负责读。
哨兵是在主服务宕机后，进行选举新的主服务。哨兵模式是对主从模式的升级，将手动操作改为自动操作，但是扩容繁琐。
如果分数一致怎么办 ？ Redis 也有一个策略：ID 号最小的从库得分最高

Redis Sentinel是Redis 的高可用性解决方案，由一个或多个Sentinel（哨兵）实例组成。它可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，它的主要功能如下：
1.监控(Monitoring)：Sentinel会不断地检查你的主服务器和从服务器是否运作正常。
2.通知(Notification)：当被监控的某个 Redis 服务器出现问题时， Sentinel可以通过API向管理员或者其他应用程序发送通知。
3.故障迁移：当主服务器不能正常工作时，Sentinel会自动进行故障迁移，也就是主从切换。
4.统一的配置：管理连接者询问sentinel取得主从的地址。

Sentinel 使用的算法核心是 Raft算法，主要用途就是用于分布式系统，系统容错，以及Leader选举，每个Sentinel都需要定期的执行以下任务：
每个 Sentinel会自动发现其他 Sentinel 和从服务器，它以每秒钟一次的频率向它所知的主服务器、从服务器以及其他Sentinel实例发送一个 PING 命令。
如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds选项所指定的值， 那么这个实例会被Sentinel标记为主观下线。 有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。
如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有Sentinel要以每秒一次的频率确认主服务器的确进入了主观下线状态。
如果一个主服务器被标记为主观下线， 并且有足够数量的Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，
那么这个主服务器被标记为客观下线。
在一般情况下， 每个Sentinel会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。当一个主服务器Sentinel标记为客观下线时，Sentinel向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10秒一次改为每秒一次。
当没有足够数量的Sentinel同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向Sentinel的 PING命令返回有效回复时， 主服务器的主观下线状态就会被移除。

集群部署：多主多从，采用哈希槽方式进行节点选，使用 Gossip 协议。

## 什么是一致性哈希算法？什么是哈希槽？
一致性哈希用于解决分布式缓存系统中的数据选择节点存储问题和数据选择节点读取问题以及在增删节点后减少数据缓存的消失范畴，防止雪崩的发生。
ConsistentHashing 一致性哈希是哈希环。2的32次方。一致性哈希可能导致服务压到一台机器上的可能。优化，可采用多个虚拟节点的方式，均匀没有顺序的分布，可以让压力分散到各个服务器。

哈希槽是在redis cluster集群方案中采用的，redis cluster集群没有采用一致性哈希方案，而是采用数据分片中的哈希槽来进行数据存储与读取的。

哈希槽是将2的14次方=16384个槽点对应着通过计算的服务器节点，如果一个节点挂了，它对应的槽点会重新再分配到其他节点上，保证了均匀分布，不会都压到一个服务器上。比如：集群有三个节点，则按照A:0-5000,B:5001-10000,C:10001-16383分配。还可以使用虚拟节点，这样增加机器基数，可以让均匀分布更加有保障。

## redis数据怎么和数据库数据保持一致(缓存一致性)
1.实时同步 同步最新的值，先操作DB,再删除Redis,查询的时候重新放入缓存。应对极端并发写和并发读（比如读写分离，DB客户端网络延迟等），用延迟双删，1-3秒后再删除。但是删除容易造成缓存击穿。如果删除Redis失败，可以放入队列中重试。
2.异步方式同步（MQ，job），但是数据会有延迟。同步锁同步，但是造成性能略低。
3.canal模仿主从复制，监听主服务器进行拉取同步数据（Flink CDC），服务成本略高。
4.触发器


想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。

如果不一致了，我们需要怎么同步：
需要引入定时任务进行缓存和DB的数据比较，在比较的过程中为了提升性能我们可以引入操作量的key，通过操作量比对进行确认是否有必要进行比对，同时可以加入时间戳的方式，只需要比对最新时间到时间戳之间的数据，减少比对量。在热门数据中，可以针对商品设置热点数据优先原则。还可以通过水位线方式，设置商品水位线，低于水位线优先原则（因为低于水位线表示不足，需要赶紧刷新以免超卖）。

## redis性能优化
1. key名设计
   （1）可读性和可管理性：要有业务域，有租户加租户，用冒号分隔（:冒号是redis文件分隔符）
   （2）简洁性：控制key的长度
   （3）不要包含特殊字符
   2.value设计
   （1）不能有bigobj，一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。bigobj会造成redis阻塞，尤其是在过期自动删除的时候。
   （2）选择适合的数据类型，减少没必要的空间
   （3）设置过期时间
   （4）优化序列化方式
   3.命令的使用
   （1）hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。
   （2）禁止使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。
   （3）使用批量操作提高效率，原生命令：例如mget、mset，非原生命令：可以使用pipeline提高效率。
   （4）Redis事务功能较弱，不建议过多使用，可以用lua替代。
   4.业务使用
   （1）避免多个应用使用一个Redis实例
   （2）使用连接池连接
   （3）高并发下增加熔断设计
   （4）配置淘汰策略

## redis单线程怎么保证高性能
单线程编程容易并且更容易维护；Redis 的性能瓶颈不在 CPU ，主要在内存和网络；也只是说它的网络 I/O 线程以及 Set 和 Get 操作是由一个线程完成的。但是 Redis 的持久化、集群同步还是使用其他线程来完成。

Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。

内存操作，数据结构相对简单，单线程减少上下文切换和竞争条件，保证顺序执行，没有多线程的消耗和锁机制，io多路复用，redis自己构建VM机制，epoll机制。

引入多线程，解决删除数据Key过大导致阻塞改成异步删除（例如 unlink key、flushdb async、flushall async 等），还有就是解决IO读写（多个socket需要串行进行拷贝）改成多个线程操作socket拷贝

## RedisBloom
要使用Redis的布隆过滤器，你需要在Redis服务器上安装RedisBloom插件。RedisBloom插件为Redis提供了布隆过滤器的功能。安装RedisBloom插件后，你还需要使用一个支持RedisBloom的客户端来与Redis服务器进行通信。

RedisBloom使用位数组（bit array）或位图（bitmap）作为底层数据结构来实现布隆过滤器。位数组是一个由0和1组成的数组，用于表示布隆过滤器中的哈希值。bitMap是一种二进制set结构。

布隆过滤器使用多个哈希函数将输入元素映射到位数组的不同位置。当添加一个元素时，布隆过滤器会计算该元素的多个哈希值，并将对应的位数组位置设置为1。当检查一个元素是否存在时，布隆过滤器会计算该元素的哈希值，并检查对应的位数组位置是否都为1。如果所有位置都为1，则认为元素可能存在；否则，元素肯定不存在。即：存在的元素不一定真存在，不存在的一定不存在。可以用在对有限数据进行判断上，比如黑名单，白名单。

需要注意的是，布隆过滤器具有一定的误报概率，即它可能会误判一个不存在的元素为存在。但是，布隆过滤器不会出现漏报，即它不会将一个存在的元素误判为不存在。通过调整位数组的大小和哈希函数的数量，可以在一定程度上控制误报概率。

## redis客户端
jedis，redisson（NIO）,RedLock（多主多从）

redisson对分布式锁加入了续期，加锁和释放锁的原子性，可重入锁。释放锁时只有自己的线程可以释放锁。
RedLock 需要多主多从，多数主上锁成功才成功，性能低。

java网络通信调用redis。

Lettuce 和 Jedis 都是 Redis 的 Java 客户端库：
连接方式：
Jedis：使用阻塞的 I/O 连接池，每个连接都是同步阻塞的。这意味着在多线程环境下，每个线程都需要从连接池中获取一个连接实例，这可能导致连接资源的竞争。
Lettuce：使用 Netty 框架构建，支持异步和同步数据访问，以及响应式编程。Lettuce 的连接是线程安全的，多个线程可以共享一个连接实例，从而减少了连接资源的竞争。
性能：
Jedis：在单线程环境下，Jedis 的性能较好，因为它使用了简单的直接连接。
Lettuce：在多线程环境下，Lettuce 的性能更优，因为它使用了高效的多路复用连接。
可扩展性：
Jedis：支持 Redis 的大部分功能，包括集群、管道、发布/订阅等。但在高并发场景下，需要管理连接池资源。
Lettuce：由于其基于 Netty 的异步连接，Lettuce 更适合于高并发场景。此外，Lettuce 还支持响应式编程，这使得它在处理大量并发请求时更具优势。
