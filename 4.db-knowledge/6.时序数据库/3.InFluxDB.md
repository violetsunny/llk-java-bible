## InFluxDB
时序数据库,go语言编写。一种较为灵活的、弱结构化的数据组织方式，虽然不需要提前定义严格的表结构，但是也必须符合一定的结构，像测量（measurement）、标签（tag）和字段（field）才能存储。
1.时序数据有这几个属性：
​  度量的数据集（measurement），类似于关系型数据库中的 table；
​  一个数据点（point），类似于关系型数据库中的 row；
​  时间戳（timestamp），表征采集到数据的时间点；
​  维度列（tag），代表数据的归属、属性，表明是哪个设备/模块产生的，一般不随着时间变化，供查询使用，类似于索引的键值对；
​  指标列（field），代表数据的测量值，随时间平滑波动。
2.特点：
数据特点：数据量大，数据随着时间增长，相同维度重复取值，指标平滑变化（某辆车的某个设备上传上来平滑变化的轨迹坐标）。
写入特点：高并发写入，且不会更新（轨迹不会更新）【基本上都是插入，没有更新的需求】。
查询特点：按不同维度对指标进行统计分析，存在明显的冷热数据，一般只会查询近期数据（一般我们只会关心近期的轨迹数据）。
数据基本上都有时间属性，随着时间的推移不断产生新的数据。
数据量大，每秒钟需要写入千万、上亿条数据
3.解决什么问题？
传统数据库通常记录数据的当前值，时序型数据库则记录所有的历史数据，在处理当前时序数据时又要不断接收新的时序数据，同时时序数据的查询也总是以时间为基础查询条件，并专注于解决以下海量数据场景的问题：
专为时序存储和高性能读写而设计：计算机虚拟世界的各种系统和应用，以及物理世界的IoT设备等都在创建海量的时序数据，每秒千万级的数据吞吐量是很常见的，而且这些数据还需要可以以非阻塞方式接收并且可压缩以节省有限的存储资源。如何支持千万级/秒数据的写入。如何支持千万级/秒数据的聚合和查询。
专为实时操作而设计：预测能力和实时决策能力，需要收到数据后，就能实时输出最新的数据分析结果，执行预定义的操作。
专为高可用性而设计：现代软件系统需要全天候可用，除了基本的集群能力，还需要根据需求自动扩容和缩容，支持柔性可用等。
成本敏感：海量数据存储带来的是成本问题，如何更低成本地存储这些数据，是时序型数据库需要解决的关键问题。
4.存储引擎：
TSM Tree（Time-Structured Merge Tree）的算法：
（1）WAL（Write-Ahead Log）：所有的写操作首先会被记录到WAL中，以确保数据的持久性。WAL是写优化的存储格式，允许数据被持久化，但不易查询。
（2）Cache：Cache是WAL中数据在内存中的表示，它在运行时被查询，并与TSM文件中的数据合并。
（3）TSM文件：TSM文件存储压缩后的列式数据，类似于LSM树中的SSTable。TSM文件由四部分组成：头部、数据块、索引和尾部。
（4）Compactor：Compactor负责将写入优化的数据格式转换为更适于读取的格式。它通过压缩数据、删除已删除的数据、优化索引和合并较小的文件来实现这一点。
（5）Compaction Planner：Compaction Planner决定哪些TSM文件准备好进行压缩，并确保多个并发的压缩操作不会相互干扰。
（6）Compression：数据压缩由特定的编码器和解码器处理，这些编码器和解码器针对不同的数据类型。压缩算法通常采用 Snappy 或 LZ4 等高效的压缩算法。
（7）Writers/Readers：每种文件类型（WAL段、TSM文件、墓碑文件等）都有相应的Writers和Readers来处理这些格式。

写入操作首先被追加到当前的WAL段和Cache中。当Cache达到一定大小时，会触发快照，将数据写入新的TSM文件，这个过程是批量进行的，以减少磁盘的随机写入操作，提高写入性能。删除操作通过向WAL写入删除条目来实现，并更新Cache和FileStore。查询操作会合并Cache和TSM文件中的数据。

TSM树的压缩（Compaction）是将写入优化的数据存储格式转换为读取优化格式的过程。它通过压缩数据、删除已删除的数据、优化索引和合并较小的文件来实现。压缩是LSM树数据管理生命周期中的关键阶段，它有助于控制磁盘使用和读写性能。同时Compaction带来了性能问题：
1.写放大问题：TSM引擎在Compaction过程中，需要对数据进行解码和重新编码，这会导致写放大问题，即实际写入到磁盘的数据量远大于原始数据量。这在高频率写入的场景下尤其明显，可能会导致性能下降和存储空间的浪费
2.读放大问题：由于TSM文件中的数据是经过编码压缩的，在读操作时需要对数据进行解码，这可能会导致读放大问题，即读取操作需要处理的数据量远大于实际需要的数据量，从而影响读取性能
3.写停顿：TSM引擎在Compaction过程中可能会暂停写入操作，这被称为写停顿。在高并发写入的场景下，频繁的Compaction可能会导致写入延迟增加，影响整体性能
4.存储占用较大：由于TSM引擎会对数据进行压缩存储，且Compaction操作可能会导致多个版本的数据共存，因此在某些情况下，存储的占用可能相对较大
5.查询放大问题：在优化Compaction操作后，InfluxDB可能会选择执行optimize compact而不是full compact，这虽然可以提升Compaction速度和减少资源消耗，但会引起查询放大问题，即查询操作需要从多个block中获取数据，增加了查询的复杂性和资源消耗。
可以通过调整cache-snapshot-memory-size参数来减少Compaction的频率和写入放大问题，但这也受到硬件配置的限制

influxDB集群版本收费！所以如何集群部署是个问题。