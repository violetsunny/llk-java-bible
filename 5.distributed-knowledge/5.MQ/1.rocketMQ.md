## 消息队列怎么用，业务场景
用于通知其他服务数据同步
复杂、耗时业务异步处理，减少接口返回时间。
大数量的切分调用（流量削峰）

Mq的线程池  等待60s尝试放入队列
发送消息，可以同步，异步，oneway发后不管单向消息

延迟消息：先放入commitlog中，通过定时任务去获取SCHEDULE_TOPIC_XXX下延迟消息，进行时间戳对比，放入consumeQueue。比如超时任务。

## MQ如何防止消息丢失
1. 消息重试  rocketMQ最多重试16次  retryTimesWhenSendFailed
2. 落库补偿
3. 死信队列（备胎）（超时的，多次消费失败的）
4. 消息持久化

丢失有发送丢失：服务ack响应即为发送成功，异常可重试； 服务丢失：服务端Broker的master和副本存储；消费丢失：消费端将主要业务执行完成再确认就行。

## MQ如何防止重复消费
1. 做幂等
2. 发送不重复，不进行补偿

## MQ如何保证顺序消费
1. 顺序放入，单个顺序消费
2. GroupID关联，各自消费各自的GroupID
3. 把需要顺序消费的消息发送到同一台broker server下的同一个队列中，而这些消息也只会被同一个消费者消费。但是没有负载均衡，压力都在一个broker的一个队列下。消息队列选择器和业务标识，进行消息队列的选择

## MQ推拉模式
1. 拉取模式（pull）也是通过偏移量offset来移动，是通过消费端主动拉取消息；消费端会从Broker主动拉取，根据能力配置拉取频率和数量。
2. 推送模式（push）需要先注册订阅消息，然后通过Listener,就可以动态知道当前的Consumer分摊了几个MessageQueue。Broker会主动推送给订阅了该消息的消费者。但其实也是pull模式，不过是长轮询+超时等待。

## MQ积压怎么处理
1. 临时扩容
2. 丢弃+重发
本质还是增强消费能力

## MQ消息负载均衡
1. producer负载均衡  轮询发送多个messagequeue到多个broker上
2. consumer负载均衡 集群（平均分queue，轮流分queue） 广播

## MQ消息存储
1. 零拷贝
2. consumerQueue消息逻辑队列和indexFile作为索引存储到commitlog，key是topic
3. 同步刷盘和异步刷盘  异步刷盘是到了内存直接返回，吞吐量大。同步需要持久化完成。
4. 主从复制（异步复制，同步复制）  
 一般选择异步刷盘和主从同步复制

## MQ的高可用
1. 生产端：会有消息重试机制，保证出现如 broker 单点故障或者网络异常等情况去做重试。当我们接收到 broker 端成功的响应为止，我们可以认为消息存储和消息的投递都是高可靠的。
2. 服务端：RocketMQ 提供了主从的策略，我们可以部署 slave 去同步数据以避免单点的问题。同时，RocketMQ 还给予了刷盘策略和同步策略中同步、异步两种方式让我们在性能和可靠性上自行抉择。
3. 消费端：在消息消费上，RocketMQ 会提供最少一次（at least once） 的消费模式，除非我们主动的告诉 broker 消费是成功的，否则 RocketMQ 不会放弃投递这个消息（进入死信主题除外）。

## MQ集群
NameServer的功能
1. 每个Broker启动的时候会向Namesrv发送注册请求，Namesrv接收Broker的请求注册路由信息，NameServer保存活跃的broker列表，包括Master和Slave；
2. 用来保存所有topic和该topic所有队列的列表；
3. NameServer用来保存所有broker的Filter列表；
4. 接收client（Producer和Consumer）的请求根据某个topic获取所有到broker的路由信息；

Broker与Namesrv的心跳机制：
单个Broker跟所有Namesrv保持心跳请求，心跳间隔为30秒，心跳请求中包括当前Broker所有的Topic信息
高可靠并发读写服务：所有发往broker的消息，有同步刷盘和异步刷盘机制，同步刷盘时，消息写入物理文件才会返回成功，因此非常可靠；异步刷盘时，只有机器宕机，才会产生消息丢失，broker挂掉可能会发生，但是机器宕机崩溃是很少发生的，除非突然断电。
负载均衡:Broker上存Topic信息，Topic由多个队列组成，队列会平均分散在多个Broker上，而Producer的发送机制保证消息尽量平均分布到所有队列中，最终效果就是所有消息都平均落在每个Broker上
高可用：集群部署时一般都为主备，Broker名相同的一组Master/Slave Broker，其中包含一个Master Broker（Broker Id为0）和0~N个Slave Broker（Broker Id不为0），备机实时从主机同步消息，如果其中一个主机宕机，备机提供消费服务，但不提供写服务。多主多从。
4.5.0以后，提供了一个新的多副本架构，这套实现称为 Dledger，而 DLedger 其实是一个基于 raft 协议的 commitlog 存储库。如果你选择了使用 Dledger 模式，DLedger commitLog 就会代替了原来的 commitLog，使得 commitLog 拥有选举复制能力。

## EMQ
基于mqtt协议的mq工具和中间件，属于长链接。

emq是基于内存的，没有持久化机制，所以会丢失数据。可以支持内置的数据库方式存储数据，可以通过规则进行数据桥接，将数据转存到其他存储库中。且可以TLS进行加密认证。

MQTT 基于发布订阅模式，它解耦了消息的发送方（发布者）和接收方（订阅者），引入了一个中间代理的角色来完成消息的路由和分发。
发布者和订阅者不需要知道彼此的存在，他们之间唯一的联系就是对消息的一致约定，例如消息将使用什么主题、消息将包含哪些字段等等。这让 MQTT 的通信更加灵活，因为我们可以随时动态地增加或减少订阅者和发布者。
通过发布订阅，我们可以轻易地实现消息的广播、组播和单播。

服务端
在发布消息的客户端和订阅的客户端之间充当中介，将所有接收到的消息转发到匹配的订阅客户端。所以有时我们也会直接将服务端称为 Broker。

客户端
使用 MQTT 协议连接到 MQTT 服务端的设备或应用程序。它既可以是发布者，也可以是订阅者，也可以具备这两种身份。

主题
主题被用来标识和区分不同的消息，它是 MQTT 消息路由的基础。发布者可以在发布时指定消息的主题，订阅者则可以选择订阅自己感兴趣的主题来接收相关的消息。

通配符
订阅者可以在订阅的主题中使用通配符来达到一次订阅多个主题的目的。MQTT 提供了单层通配符和多层通配符两种主题通配符，以满足不同的订阅需要。

QoS
MQTT 定义了三种 QoS 等级，来分别提供不同的消息可靠性保证。每条消息都可以在发布时独立设置自己的 QoS。QoS 0 最多交付一次，消息可能丢失；QoS 1 至少交付一次，消息不丢失，但是可能重复；QoS 2 只交付一次，消息不丢失，并且不会重复，性能差。QoS 越大，消息的传输复杂程度也越高，我们需要根据实际场景来选择合适的 QoS。

认证
认证指的是在客户端连接到 MQTT 消息中间件时，需要对客户端的身份进行验证。，EMQX 支持多种认证机制，如密码认证，JWT 认证，以及基于 MQTT 5.0 协议的增强认证。EMQX 支持的密码认证、 JWT 认证和 MQTT 5.0 增强认证。

授权
鉴权则是指对通过身份验证的客户端授予相应的访问级别和权限。通过身份验证的机制和细粒度的授权，能够确保只有经过授权的客户端可以连接到您的 MQTT 消息中间件和执行特定操作。通过内置数据库、文件、或通过集成 MySQL、PostgreSQL、MongoDB 和 Redis 进行授权相关操作。

黑名单
EMQX 为用户提供了黑名单功能，用户可以通过 Dashboard 和 HTTP API 将指定客户端加入黑名单以拒绝该客户端访问，除了客户端标识符以外，还支持直接封禁用户名甚至 IP 地址。