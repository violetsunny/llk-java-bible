## 库存
预占库存

消费者拍下商品订单后，库存系统先为该订单预留库存，这个预留库存的动作被称为库存预占。是现代电商中预售的核心流程。
针对这种高并发，我们一般都是限流加缓存。

同时针对请求，需要进行排序扣减。这就需要加锁，加锁后需要避免死锁的问题，要注意对加锁对象排序，不能造成锁依赖等待。为了加快锁释放的速度，可以使用缓存扣减。
为了初始化数据复杂的问题，可以简单如果没有缓存数据就走DB预占，如果有缓存数据就走缓存预占。预占的过程中，可以使用MQ异步更新DB。

需要解决缓存和DB不一致的情况：

可以引入操作量缓存，比对公式：库存缓存+操作量=DB库存。由于会有消费延迟的问题，所以我们还需要进行多次比对，只要成功一次即可。
由于库存变动过于频繁，甚至达百万次。所以我们可以设置水位线模式和热点物料模式，使用低于水位线优先更新原则，同时热点库存物料优先原则。

对于全部商品回滚，我还是不赞同的。我认为应该排序预占，不成功则抛弃让给下一个请求。

确保取消限购操作Redis/DB最终一致：

由于提交限购记录可能会出现积压，取消限购时提交限购记录还未写入，导致取消限购时未能删除对应的提交记录。我们通过延迟消息补偿重试，确保取消限购操作(Redis/DB)最终一致。在取消限购的时候，删除限购记录影响行数为0时，发送MQ延迟消息，在Consumer端消费消息，重试取消限购，并通过埋点与监控检测核心指标是否有异常。
商品上线的时候将库存写入Redis，在活动扣减库存时，使用incrby原子扣减成功后将扣减消息MQ发出，在Consumer端消费消息执行DB扣减库存，若下单失败，执行还库存操作，也是先操作Redis，再发MQ，在Consumer端，执行DB还库存，如果未查询到扣减记录（可能扣库存MQ有延迟），则延时重试，并通过埋点与监控检测核心指标是否有异常。

分桶分库存：

秒杀开始前提前锁定库存修改，并执行分桶策略，按照库存取模分为N个桶, 每个分桶对应缓存的Key为Key [0~ N-1]，每个分桶保存m个库存初始化到Redis，秒杀时根据 Hash(Uid)%N 路由到不同的桶进行扣减，解决所有流量访问单个Key对单个Redis实例造成压力。

库存扣减这块，也有一些优化思路：
1. 给每个消息针对sku做hash路由，保证同一个类目下的sku分配到同一内存队列下，然后批量更新库存，基本就是通过hash和内存队列来保证顺序，这样不会有死锁了。会有消息偏向不均匀的问题。
2. 合并请求，会有延迟问题。
3. 拆行，将一行库存数据拆成多行，这样可以并行扣减。会带来复杂的业务逻辑。
4. 允许部分超卖的问题，需要业务决定多少系数的超卖以及超卖部分业务怎么处理闭环。
5. 读走弱一致缓存，写走DB。让DB的读取压力大大减少。在写的请求下，可以通过分布式锁和限流等手段将流量减缓，可通过DB自身事务保证原子性。异步更新缓存的方式。
